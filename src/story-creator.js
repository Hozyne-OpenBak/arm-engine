/**
 * story-creator.js - Story Creation Automation
 * 
 * Automatically creates Story issues in the governance repository
 * when outdated dependencies are detected.
 * 
 * Story: #16
 * Epic: #13
 */

const { execSync } = require('child_process');

/**
 * @typedef {Object} Story
 * @property {number} number - Issue number
 * @property {string} title - Story title
 * @property {string} url - GitHub issue URL
 * @property {import('./scanner').Dependency} dependency - Associated dependency
 */

/**
 * @typedef {Object} StoryCreatorConfig
 * @property {string} governanceRepo - Governance repository (owner/name)
 * @property {number} epicNumber - Epic issue number to link to
 * @property {string} targetRepo - Target repository being maintained
 */

class StoryCreator {
  /**
   * @param {StoryCreatorConfig} config
   */
  constructor(config) {
    if (!config.governanceRepo) {
      throw new Error('governanceRepo is required');
    }
    if (!config.epicNumber) {
      throw new Error('epicNumber is required');
    }
    if (!config.targetRepo) {
      throw new Error('targetRepo is required');
    }

    this.governanceRepo = config.governanceRepo;
    this.epicNumber = config.epicNumber;
    this.targetRepo = config.targetRepo;
  }

  /**
   * Generate Story title
   * @private
   * @param {import('./scanner').Dependency} dep
   * @param {string} ecosystem
   * @returns {string}
   */
  generateTitle(dep, ecosystem = 'nodejs') {
    const ecosystemLabel = this.getEcosystemLabel(ecosystem);
    return `Update ${dep.package} (${ecosystemLabel}) from ${dep.current} to ${dep.wanted}`;
  }

  /**
   * Get human-readable ecosystem label
   * @private
   * @param {string} ecosystem
   * @returns {string}
   */
  getEcosystemLabel(ecosystem) {
    const labels = {
      'nodejs': 'Node.js',
      'python': 'Python',
      'ruby': 'Ruby',
      'go': 'Go'
    };
    return labels[ecosystem] || ecosystem;
  }

  /**
   * Generate Story body
   * @private
   * @param {import('./scanner').Dependency} dep
   * @param {string} ecosystem
   * @returns {string}
   */
  generateBody(dep, ecosystem = 'nodejs') {
    const ecosystemLabel = this.getEcosystemLabel(ecosystem);
    const changeTypeLabel = dep.type.charAt(0).toUpperCase() + dep.type.slice(1);

    return `## Story: Update ${dep.package} from ${dep.current} to ${dep.wanted}

### Epic
#${this.epicNumber} — ARM v1: Autonomous Repo Maintenance (MVP)

### Objective
Update \`${dep.package}\` dependency in \`${this.targetRepo}\` to address outdated ${ecosystemLabel} package.

### Target Repository
\`${this.targetRepo}\`

### Change Details
- **Package:** ${dep.package}
- **Ecosystem:** ${ecosystemLabel}
- **Current version:** ${dep.current}
- **Target version:** ${dep.wanted}
- **Latest version:** ${dep.latest}
- **Change type:** ${changeTypeLabel}
- **Location:** ${dep.location}

### Goals
- Update package to recommended version
- Maintain compatibility (${dep.type} update only)
- Regenerate lock files
- Pass all validation checks

### Non-Goals
- Breaking changes (major version updates)
- Multi-package updates in single PR
- Dependency conflict resolution (defer to manual review)

### Acceptance Criteria
- [ ] Package manifest updated with new version
- [ ] Lock file regenerated
- [ ] No breaking changes introduced
- [ ] PR created and linked to this Story
- [ ] PR passes validation workflow
- [ ] Human review completed

### Tasks
- [ ] Update package manifest (\`package.json\`, \`requirements.txt\`, etc.)
- [ ] Regenerate lock file (\`package-lock.json\`, \`poetry.lock\`, etc.)
- [ ] Run basic smoke tests (if available)
- [ ] Create PR with Story reference
- [ ] Link PR to this Story

### Implementation Notes
**Change type:** ${changeTypeLabel} update (${dep.current} → ${dep.wanted})  
${dep.wanted !== dep.latest ? `**Note:** Latest version is ${dep.latest}, but ${dep.wanted} is recommended based on current version constraints.` : ''}

**Recommended approach:**
1. Update version in package manifest
2. Run package manager install/update command
3. Verify lock file changes
4. Commit with message: "Update ${dep.package} from ${dep.current} to ${dep.wanted}"

### PR Link
*Will be added when PR is created*

---
**Status:** Draft  
**Automated:** true  
**Generated by:** ARM v1  
**Scanned at:** ${new Date().toISOString()}`;
  }

  /**
   * Create Story issue in governance repository
   * @param {import('./scanner').Dependency} dep - Dependency to create Story for
   * @param {string} ecosystem - Ecosystem identifier (nodejs, python, etc.)
   * @param {boolean} dryRun - If true, return Story data without creating issue
   * @returns {Promise<Story>}
   */
  async createStory(dep, ecosystem = 'nodejs', dryRun = false) {
    const title = this.generateTitle(dep, ecosystem);
    const body = this.generateBody(dep, ecosystem);

    if (dryRun) {
      // Dry-run mode: return mock Story
      return {
        number: 0,
        title,
        url: `https://github.com/${this.governanceRepo}/issues/0 (dry-run)`,
        body,
        dependency: dep
      };
    }

    // Create issue via gh CLI
    try {
      const labels = [
        'story',
        'type/task',
        'status/draft',
        'priority/p1'
      ].join(',');

      // Write body to temp file to avoid shell escaping issues
      const tempFile = `/tmp/arm-story-body-${Date.now()}.md`;
      require('fs').writeFileSync(tempFile, body, 'utf8');

      const command = `gh issue create --repo ${this.governanceRepo} --title "${title.replace(/"/g, '\\"')}" --label "${labels}" --body-file "${tempFile}"`;

      const output = execSync(command, {
        encoding: 'utf8',
        stdio: 'pipe'
      }).trim();

      // Clean up temp file
      require('fs').unlinkSync(tempFile);

      // Parse issue URL from output
      const issueUrl = output;
      const issueNumber = parseInt(issueUrl.split('/').pop(), 10);

      return {
        number: issueNumber,
        title,
        url: issueUrl,
        dependency: dep
      };
    } catch (error) {
      throw new Error(`Failed to create Story issue: ${error.message}`);
    }
  }

  /**
   * Check if Story already exists for this dependency
   * @param {import('./scanner').Dependency} dep
   * @returns {Promise<Story | null>}
   */
  async findExistingStory(dep) {
    try {
      // Search for open Stories matching package and target version
      // Note: Not including "from ${dep.current}" since current can be "unknown"
      const searchQuery = `repo:${this.governanceRepo} is:issue is:open "${dep.package}" "to ${dep.wanted}" in:title`;
      const command = `gh issue list --repo ${this.governanceRepo} --search "${searchQuery}" --json number,title,url,body --limit 10`;

      const output = execSync(command, {
        encoding: 'utf8',
        stdio: 'pipe'
      }).trim();

      if (!output) return null;

      const issues = JSON.parse(output);
      
      // Look for exact match on package + target version + target repo
      for (const issue of issues) {
        const titleMatches = issue.title.includes(`${dep.package}`) && 
                           issue.title.includes(`to ${dep.wanted}`);
        const bodyMatches = issue.body && issue.body.includes(this.targetRepo);
        
        if (titleMatches && bodyMatches) {
          console.log(`✓ Found existing Story: #${issue.number}`);
          return {
            number: issue.number,
            title: issue.title,
            url: issue.url,
            dependency: dep
          };
        }
      }

      return null;
    } catch (error) {
      // Fail gracefully if search fails
      console.warn(`⚠️  Warning: Could not search for existing Story: ${error.message}`);
      return null;
    }
  }

  /**
   * Create Story with duplicate detection
   * @param {import('./scanner').Dependency} dep
   * @param {string} ecosystem
   * @param {boolean} dryRun
   * @returns {Promise<{story: Story, wasReused: boolean}>}
   */
  async createStoryIfNotExists(dep, ecosystem = 'nodejs', dryRun = false) {
    // Check for existing Story
    const existing = await this.findExistingStory(dep);
    if (existing) {
      return { story: existing, wasReused: true };
    }

    // Create new Story
    const story = await this.createStory(dep, ecosystem, dryRun);
    return { story, wasReused: false };
  }
}

module.exports = { StoryCreator };
