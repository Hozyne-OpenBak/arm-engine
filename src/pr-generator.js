/**
 * pr-generator.js - PR Generation with Story Reference
 * 
 * Automatically creates PRs in the target repository that update
 * dependencies and reference the corresponding Story issue.
 * 
 * Story: #17, #35
 * Epic: #13, #30
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const { retryWithBackoff } = require('./utils/retry');

/**
 * @typedef {Object} PR
 * @property {number} number - PR number
 * @property {string} url - GitHub PR URL
 * @property {string} branch - Feature branch name
 * @property {number} storyNumber - Associated Story issue number
 * @property {import('./scanner').Dependency} dependency - Associated dependency
 */

/**
 * @typedef {Object} PRGeneratorConfig
 * @property {string} targetRepo - Target repository (owner/name)
 * @property {string} baseBranch - Base branch (default: main)
 * @property {string} workspaceDir - Workspace directory for cloning
 */

class PRGenerator {
  /**
   * @param {PRGeneratorConfig} config
   */
  constructor(config) {
    if (!config.targetRepo) {
      throw new Error('targetRepo is required');
    }

    this.targetRepo = config.targetRepo;
    this.baseBranch = config.baseBranch || 'main';
    this.workspaceDir = config.workspaceDir || '/tmp/arm-workspace';
    this.repoPath = path.join(this.workspaceDir, config.targetRepo.split('/')[1]);
  }

  /**
   * Ensure repository is cloned or updated
   * @private
   */
  async ensureRepo() {
    if (!fs.existsSync(this.workspaceDir)) {
      fs.mkdirSync(this.workspaceDir, { recursive: true });
    }

    if (fs.existsSync(this.repoPath)) {
      // Pull latest
      try {
        execSync(`git checkout ${this.baseBranch}`, { cwd: this.repoPath, stdio: 'pipe' });
        execSync('git pull', { cwd: this.repoPath, stdio: 'pipe' });
      } catch (error) {
        throw new Error(`Failed to update repository: ${error.message}`);
      }
    } else {
      // Clone
      try {
        const cloneUrl = `https://github.com/${this.targetRepo}.git`;
        execSync(`git clone ${cloneUrl} ${this.repoPath}`, { 
          cwd: this.workspaceDir, 
          stdio: 'pipe' 
        });
      } catch (error) {
        throw new Error(`Failed to clone repository: ${error.message}`);
      }
    }
  }

  /**
   * Generate branch name for dependency update
   * @private
   * @param {import('./scanner').Dependency} dep
   * @returns {string}
   */
  generateBranchName(dep) {
    const packageSlug = dep.package.replace(/[@\/]/g, '-').toLowerCase();
    const versionSlug = dep.wanted.replace(/\./g, '-');
    return `arm/update-${packageSlug}-${versionSlug}`;
  }

  /**
   * Generate commit message
   * @private
   * @param {import('./scanner').Dependency} dep
   * @returns {string}
   */
  generateCommitMessage(dep) {
    return `Update ${dep.package} from ${dep.current} to ${dep.wanted}`;
  }

  /**
   * Generate PR title
   * @private
   * @param {import('./scanner').Dependency} dep
   * @param {number} storyNumber
   * @returns {string}
   */
  generatePRTitle(dep, storyNumber) {
    return `[Story #${storyNumber}] Update ${dep.package} from ${dep.current} to ${dep.wanted}`;
  }

  /**
   * Generate PR body
   * @private
   * @param {import('./scanner').Dependency} dep
   * @param {number} storyNumber
   * @param {string} governanceRepo
   * @returns {string}
   */
  generatePRBody(dep, storyNumber, governanceRepo) {
    const changeTypeLabel = dep.type.charAt(0).toUpperCase() + dep.type.slice(1);

    return `## Update ${dep.package} from ${dep.current} to ${dep.wanted}

### Story
Closes ${governanceRepo}#${storyNumber}

### Change Summary
Updates \`${dep.package}\` dependency to address outdated version.

- **Package:** ${dep.package}
- **Current:** ${dep.current}
- **Target:** ${dep.wanted}
- **Latest:** ${dep.latest}
- **Change type:** ${changeTypeLabel}

${dep.wanted !== dep.latest ? `**Note:** Latest version is ${dep.latest}, but ${dep.wanted} is recommended based on current version constraints.\n` : ''}
### Changes
- \`package.json\`: Updated \`${dep.package}\` version
- \`package-lock.json\`: Regenerated via \`npm install\`

### Testing
- [x] package-lock.json regenerated
- [x] No breaking changes (${dep.type} update only)
- [ ] Manual review recommended

### Governance
- Story: [#${storyNumber}](https://github.com/${governanceRepo}/issues/${storyNumber})
- Epic: [#13](https://github.com/${governanceRepo}/issues/13)
- Automated by: ARM v1

---
**Automated PR** — Generated by ARM v1 Autonomous Repo Maintenance`;
  }

  /**
   * Update package.json with new dependency version
   * @private
   * @param {import('./scanner').Dependency} dep
   * @returns {boolean} True if package.json was modified
   */
  updatePackageJson(dep) {
    const packageJsonPath = path.join(this.repoPath, 'package.json');
    
    if (!fs.existsSync(packageJsonPath)) {
      throw new Error('package.json not found');
    }

    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    let modified = false;

    // Update in dependencies or devDependencies
    if (packageJson.dependencies && packageJson.dependencies[dep.package]) {
      packageJson.dependencies[dep.package] = `^${dep.wanted}`;
      modified = true;
    }

    if (packageJson.devDependencies && packageJson.devDependencies[dep.package]) {
      packageJson.devDependencies[dep.package] = `^${dep.wanted}`;
      modified = true;
    }

    if (packageJson.optionalDependencies && packageJson.optionalDependencies[dep.package]) {
      packageJson.optionalDependencies[dep.package] = `^${dep.wanted}`;
      modified = true;
    }

    if (!modified) {
      throw new Error(`Package ${dep.package} not found in package.json dependencies`);
    }

    // Write updated package.json
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n', 'utf8');
    
    return true;
  }

  /**
   * Check if there are uncommitted changes
   * @private
   * @returns {boolean}
   */
  checkForChanges() {
    try {
      const status = execSync('git status --porcelain', {
        cwd: this.repoPath,
        encoding: 'utf8',
        stdio: 'pipe'
      }).trim();
      
      return status.length > 0;
    } catch (error) {
      throw new Error(`Failed to check git status: ${error.message}`);
    }
  }

  /**
   * Create feature branch and apply changes
   * @private
   * @param {string} branchName
   * @param {import('./scanner').Dependency} dep
   */
  async applyChanges(branchName, dep) {
    try {
      // Create and checkout feature branch
      execSync(`git checkout -b ${branchName}`, {
        cwd: this.repoPath,
        stdio: 'pipe'
      });

      // Update package.json
      this.updatePackageJson(dep);

      // Run npm install to regenerate package-lock.json
      execSync('npm install', {
        cwd: this.repoPath,
        stdio: 'pipe'
      });

      // Check if there are any changes to commit
      const hasChanges = this.checkForChanges();
      if (!hasChanges) {
        console.log('⚠️  No changes detected after npm install. Package may already be at target version.');
        console.log('   Skipping commit and push.');
        // Clean up: switch back to base branch and delete feature branch
        execSync(`git checkout ${this.baseBranch}`, {
          cwd: this.repoPath,
          stdio: 'pipe'
        });
        execSync(`git branch -D ${branchName}`, {
          cwd: this.repoPath,
          stdio: 'pipe'
        });
        return false;
      }

      // Stage changes
      execSync('git add package.json package-lock.json', {
        cwd: this.repoPath,
        stdio: 'pipe'
      });

      // Commit
      const commitMessage = this.generateCommitMessage(dep);
      execSync(`git commit -m "${commitMessage}"`, {
        cwd: this.repoPath,
        stdio: 'pipe'
      });

      // Push branch
      execSync(`git push -u origin ${branchName}`, {
        cwd: this.repoPath,
        stdio: 'pipe'
      });

      return true;

    } catch (error) {
      throw new Error(`Failed to apply changes: ${error.message}`);
    }
  }

  /**
   * Check if PR already exists for this dependency update
   * @param {import('./scanner').Dependency} dep
   * @returns {Promise<PR | null>}
   */
  async findExistingPR(dep) {
    try {
      const expectedBranch = this.generateBranchName(dep);
      
      // Search for open PRs matching package name with retry logic
      const searchQuery = `repo:${this.targetRepo} is:pr is:open ${dep.package} in:title`;
      const command = `gh pr list --repo ${this.targetRepo} --search "${searchQuery}" --json number,title,url,headRefName --limit 10`;

      // Wrap gh CLI call with retry logic
      const output = await retryWithBackoff(async () => {
        return execSync(command, {
          encoding: 'utf8',
          stdio: 'pipe'
        }).trim();
      });

      if (!output) return null;

      const prs = JSON.parse(output);
      
      // Look for exact match by branch name OR package + target version
      for (const pr of prs) {
        const branchMatches = pr.headRefName === expectedBranch;
        const titleMatches = pr.title.includes(`${dep.package}`) && 
                           pr.title.includes(`to ${dep.wanted}`);
        
        if (branchMatches || titleMatches) {
          console.log(`✓ Found existing PR: #${pr.number}`);
          return {
            number: pr.number,
            url: pr.url,
            branch: pr.headRefName,
            storyNumber: 0, // Unknown from search
            dependency: dep
          };
        }
      }

      return null;
    } catch (error) {
      // Fail gracefully if search fails
      console.warn(`⚠️  Warning: Could not search for existing PR: ${error.message}`);
      return null;
    }
  }

  /**
   * Create PR in target repository
   * @param {import('./scanner').Dependency} dep - Dependency to update
   * @param {number} storyNumber - Story issue number from governance repo
   * @param {string} governanceRepo - Governance repository (owner/name)
   * @param {boolean} dryRun - If true, simulate PR creation without actual changes
   * @returns {Promise<PR>}
   */
  async createPR(dep, storyNumber, governanceRepo, dryRun = false) {
    const branchName = this.generateBranchName(dep);
    const title = this.generatePRTitle(dep, storyNumber);
    const body = this.generatePRBody(dep, storyNumber, governanceRepo);

    if (dryRun) {
      // Dry-run mode: return mock PR
      return {
        number: 0,
        url: `https://github.com/${this.targetRepo}/pull/0 (dry-run)`,
        branch: branchName,
        storyNumber,
        dependency: dep,
        body
      };
    }

    // Ensure repo is available
    await this.ensureRepo();

    // Check for existing PR
    const existing = await this.findExistingPR(dep);
    if (existing) {
      console.log(`PR already exists: #${existing.number} - ${existing.url}`);
      return existing;
    }

    // Apply changes and push branch
    const changesApplied = await this.applyChanges(branchName, dep);
    
    // If no changes were applied, return null (no PR to create)
    if (!changesApplied) {
      return null;
    }

    // Create PR via gh CLI with retry logic
    try {
      // Write body to temp file to avoid shell escaping issues
      const tempFile = `/tmp/arm-pr-body-${Date.now()}.md`;
      fs.writeFileSync(tempFile, body, 'utf8');

      const command = `gh pr create --repo ${this.targetRepo} --head ${branchName} --base ${this.baseBranch} --title "${title.replace(/"/g, '\\"')}" --body-file "${tempFile}"`;

      // Wrap gh CLI call with retry logic
      const output = await retryWithBackoff(async () => {
        return execSync(command, {
          encoding: 'utf8',
          stdio: 'pipe'
        }).trim();
      });

      // Clean up temp file
      fs.unlinkSync(tempFile);

      // Parse PR URL from output
      const prUrl = output;
      const prNumber = parseInt(prUrl.split('/').pop(), 10);

      return {
        number: prNumber,
        url: prUrl,
        branch: branchName,
        storyNumber,
        dependency: dep
      };
    } catch (error) {
      throw new Error(`Failed to create PR: ${error.message}`);
    }
  }

  /**
   * Clean up workspace (remove cloned repo)
   */
  cleanup() {
    if (fs.existsSync(this.repoPath)) {
      fs.rmSync(this.repoPath, { recursive: true, force: true });
    }
  }
}

module.exports = { PRGenerator };
